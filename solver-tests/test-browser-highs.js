/**
 * Test: Browser HiGHS Solver Simulation
 * 
 * This simulates how HiGHS runs in the browser with the exact same
 * LP format generated by highsWrapper.ts
 * 
 * Run with: node test-browser-highs.js
 */

import highsLoader from 'highs';

// Simulate the realistic problem sizes
const testCases = [
  { accounts: 10, reps: 5, name: 'Small (50 vars)' },
  { accounts: 34, reps: 8, name: 'Real issue size (272 vars)' },
  { accounts: 50, reps: 10, name: 'Medium (500 vars)' },
  { accounts: 100, reps: 15, name: 'Large (1500 vars)' },
  { accounts: 200, reps: 20, name: 'Very Large (4000 vars)' },
];

async function runTests() {
  console.log('='.repeat(60));
  console.log('Browser HiGHS Solver Simulation Test');
  console.log('='.repeat(60));
  
  let highs;
  try {
    console.log('\nLoading HiGHS...');
    highs = await highsLoader();
    console.log('HiGHS loaded successfully\n');
  } catch (err) {
    console.error('FATAL: Failed to load HiGHS:', err.message);
    return;
  }
  
  const results = [];
  
  for (const tc of testCases) {
    console.log(`\n=== ${tc.name} (${tc.accounts} accounts × ${tc.reps} reps) ===`);
    
    const lp = buildRealisticLP(tc.accounts, tc.reps);
    console.log(`LP: ${lp.length} chars, ${lp.split('\n').length} lines`);
    console.log(`Binary vars: ${tc.accounts * tc.reps}`);
    
    const startTime = Date.now();
    
    try {
      // Try with options first (like browser code does)
      let solution;
      try {
        solution = highs.solve(lp, {
          presolve: 'on',
          time_limit: 60,
          mip_rel_gap: 0.01,
          output_flag: false,
        });
      } catch (optErr) {
        console.log(`  Options failed: ${optErr.message}`);
        console.log('  Trying without options...');
        solution = highs.solve(lp);
      }
      
      const elapsed = Date.now() - startTime;
      
      console.log(`  Status: ${solution.Status}`);
      console.log(`  Objective: ${solution.ObjectiveValue}`);
      console.log(`  Columns: ${Object.keys(solution.Columns || {}).length}`);
      console.log(`  Time: ${elapsed}ms`);
      
      results.push({ 
        name: tc.name, 
        success: solution.Status === 'Optimal' || solution.Status === 'Feasible',
        status: solution.Status,
        time: elapsed 
      });
      
    } catch (err) {
      const elapsed = Date.now() - startTime;
      console.log(`  FAILED: ${err.message}`);
      results.push({ 
        name: tc.name, 
        success: false, 
        error: err.message,
        time: elapsed 
      });
      
      // Check if we need to reload HiGHS after crash
      if (err.message.includes('Aborted') || err.message.includes('memory')) {
        console.log('  Attempting to reload HiGHS after crash...');
        try {
          highs = await highsLoader();
          console.log('  HiGHS reloaded successfully');
        } catch (reloadErr) {
          console.log('  HiGHS reload FAILED:', reloadErr.message);
          break;
        }
      }
    }
  }
  
  // Summary
  console.log('\n' + '='.repeat(60));
  console.log('SUMMARY');
  console.log('='.repeat(60));
  
  for (const r of results) {
    const status = r.success ? '✓ PASS' : '✗ FAIL';
    const detail = r.success ? `${r.status} (${r.time}ms)` : r.error;
    console.log(`${status}: ${r.name} - ${detail}`);
  }
  
  // Now test repeated solves on same instance (state corruption test)
  console.log('\n' + '='.repeat(60));
  console.log('STATE CORRUPTION TEST: Repeated solves on same instance');
  console.log('='.repeat(60));
  
  const smallLP = buildRealisticLP(10, 5);
  let consecutiveFailures = 0;
  
  for (let i = 0; i < 10; i++) {
    try {
      const solution = highs.solve(smallLP);
      console.log(`Solve ${i + 1}: ${solution.Status}`);
      consecutiveFailures = 0;
    } catch (err) {
      console.log(`Solve ${i + 1}: FAILED - ${err.message}`);
      consecutiveFailures++;
      if (consecutiveFailures >= 3) {
        console.log('Too many consecutive failures, stopping test');
        break;
      }
    }
  }
}

/**
 * Build LP format matching what highsWrapper.ts generates
 */
function buildRealisticLP(accounts, reps) {
  const lines = [];
  const arrTarget = 150000;
  const MAX_LINE_LENGTH = 200;
  
  // Objective function with realistic scoring
  lines.push('Maximize');
  
  let objLine = ' obj:';
  for (let a = 0; a < accounts; a++) {
    for (let r = 0; r < reps; r++) {
      // Realistic score: 0.3 to 1.0
      const score = (0.3 + Math.random() * 0.7).toFixed(6);
      const term = ` + ${score} x${a}_${r}`;
      
      if (objLine.length + term.length > MAX_LINE_LENGTH) {
        lines.push(objLine);
        objLine = term;
      } else {
        objLine += term;
      }
    }
  }
  
  // Add slack penalties (Big-M pattern)
  for (let r = 0; r < reps; r++) {
    const alphaPenalty = ' - 0.000001 ao' + r + ' - 0.000001 au' + r;
    const betaPenalty = ' - 0.0001 bo' + r + ' - 0.0001 bu' + r;
    const bigMPenalty = ' - 0.01 mo' + r + ' - 0.01 mu' + r;
    
    if (objLine.length + alphaPenalty.length > MAX_LINE_LENGTH) {
      lines.push(objLine);
      objLine = alphaPenalty + betaPenalty + bigMPenalty;
    } else {
      objLine += alphaPenalty + betaPenalty + bigMPenalty;
    }
  }
  
  if (objLine.trim().length > 0) {
    lines.push(objLine);
  }
  
  lines.push('Subject To');
  
  // Assignment constraints: each account assigned exactly once
  for (let a = 0; a < accounts; a++) {
    let constraint = ` a${a}:`;
    for (let r = 0; r < reps; r++) {
      constraint += ` + 1 x${a}_${r}`;
    }
    constraint += ' = 1';
    lines.push(constraint);
  }
  
  // Balance constraints with Big-M slacks
  for (let r = 0; r < reps; r++) {
    let constraint = ` b${r}:`;
    for (let a = 0; a < accounts; a++) {
      const arr = Math.floor(10000 + Math.random() * 100000);
      constraint += ` + ${arr} x${a}_${r}`;
    }
    // Add all slack variables
    constraint += ` - 1 ao${r} + 1 au${r}`;
    constraint += ` - 1 bo${r} + 1 bu${r}`;
    constraint += ` - 1 mo${r} + 1 mu${r}`;
    constraint += ` = ${arrTarget}`;
    lines.push(constraint);
  }
  
  lines.push('Bounds');
  
  // Slack bounds (Big-M pattern)
  for (let r = 0; r < reps; r++) {
    const alphaBound = arrTarget * 0.1;
    const betaBound = arrTarget * 0.3;
    
    lines.push(` 0 <= ao${r} <= ${alphaBound}`);
    lines.push(` 0 <= au${r} <= ${alphaBound}`);
    lines.push(` 0 <= bo${r} <= ${betaBound}`);
    lines.push(` 0 <= bu${r} <= ${betaBound}`);
    lines.push(` mo${r} >= 0`);
    lines.push(` mu${r} >= 0`);
  }
  
  lines.push('Binary');
  for (let a = 0; a < accounts; a++) {
    for (let r = 0; r < reps; r++) {
      lines.push(` x${a}_${r}`);
    }
  }
  
  lines.push('End');
  
  return lines.join('\n');
}

runTests().catch(console.error);




